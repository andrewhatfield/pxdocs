---
title: Overview
description: Explanation on the security model used in Portworx
keywords: portworx, security, ownership, tls, rbac, claims, jwt, oidc
weight: 10
series: authorization
---

From version 2.1, Portworx has support for security. This document provides a
high level overview of the different components used to secure Portworx.

Portworx security centers around the obiquitous JWT based authentication and
authorization model. This technology is currently used by most major internet
systems, providing a proven secure model for user and account identification.

A token is generated by a token authority(TA) and signed using either a private
key or a shared secret. The generated token would then be provided to Portworx
by the user to identify them. No passwords are ever sent to Portworx.

Using this secure model enables Portworx to only have to verify the validity of
the token to authenticate the user. Portworx then destroys the token ensuring
tokens are never saved on a Portworx system.

The token contains a section called _claims_ which not only identifies the
user, but also provides authorization information like RBAC. Portworx uses
the RBAC information to determine if the user is authorized to make the request.

Once Portworx has authenticated and authorized the user, it can then use
the username of the user and group information available in the claims to
determine if they have access to a resource requested.

## Terminology

| Term | Definition |
| ---- | ---------- |
| ACL | Access Control List identifying those accounts which can access a resource|
| claims | Information contained in the payload of the JWT identifying the owner of the request |
| CO | Container Orchestration System like Kubernetes, Mesosphere, or Nomad |
| JWT | JSON Web Token |
| OIDC | OpenID Connect |
| RBAC | Role Based Access Control defined by the rules of a role |
| role | A named set of rules |
| rules | A description of the permissions for a role |
| token | A JSON Web Token which is signed by a token authority identifying the owner of the request |
| token authority | Application used to generate and sign an identification token |


## Security Models
Portworx security is composed of three models:

1. **Authentication**: A model for verifying the token is correct and generated from
   a truster issuer.
1. **Authorization**: A model for verifying access to a particular request type
   according to the role or roles applied to the user.
1. **Ownership**: A model for determining access to resources.

## Token

Portworx security supports two types of token generation models: _OIDC_ and
_self-generated_ tokens.  OpenID Connect (or OIDC) is a standard model for user
authentication and management and is a great solution for enterprise customers
due to its integration with SAML 2.0, Active Directory, and/or LDAP. The second
model, is a self-generated token, where the administrator would generate a token
either using their own TA application. For convenience, Portworx provides a
method of generating tokens using `pxctl`.

For Portworx to verify these tokens are valid, they must be signed with either
a shared secret, or an RSA or an ECDSA private key, and Portworx configured
with the same shared secret or pair public keys.

### Required JWT claims
Portworx requires a set of claims to be provided to authorize the user. The
following table has the set of required claims:

| Claim | Type | Description |
| ----- | ---- | ----------- |
| iss   | string | Name of the issuer. Portworx utilizes this information to determine if the token was issued by a trusted token authority |
| sub | string | Unique identifier of the user, used to determine access control of resources |
| exp | date | Expiration date |
| iat | date | Issued at time |
| name | string | Name of the user |
| email | string | Email of the user. Portworx may be configured to use the email as the unique identifier of the user |
| roles | string array | (custom claim) Portworx RBAC roles |
| groups | string array | (custom claim) List of groups user is part of, used determine access control of resources |

### Self-Generated Tokens
Token generation can be done by any JWT compliant application which
sets the claims required by Portworx. For convenience, administrators can
generate user tokens using `pxctl`. See [Generating Tokens](/reference/cli/authorization/#generate_tokens).

### OpenID Connect (OIDC)
Due to its ability to manage thousands of users, it is highly recommended that
enterprise customers deploy an OIDC service. There are multiple public
and private OIDC providers. Customers could use public providers such as
Okta.com, Auth0.com, etc, or private providers such as Keycloak, CloudFoundry
UAA, Dex, or Tremolo Securitys OpenUnison.

In the case where the claims required by Portworx security do not match with
those provided by the customer, most OIDC have a mapping feature. This feature
allows the OIDC system to return a token to Portworx where the claims have the
appropriate information. Some OIDCs may namespace custom claims whic his
supported, but the namespace value must be provided to the system during
initialization.

## Authentication
Portworx will determine the validity of a user through a token based model. The
token will be created by the TA and will contain information about the user in
the _claims_ section. When Portworx receives a request from the user, it will
check the token validity by verifying its signature using either a shared
secrete or public key provided during configuration.

## Authorization
Once the token has been determined to be valid, Portworx then checks if the
user is authorized to make the request. The _roles_ claim in the token
must contain the name of an existing default or customer registered role in the
Portworx system. A role is the name to a set of RBAC rules which enable access
to certain SDK calls. Custom roles can be created using `pxctl` or through the
[OpenStorage SDK](https://libopenstorage.github.io/w/release-6.0.generated-api.html#serviceopenstorageapiopenstoragerole).

See also [Role management using pxctl](/reference/cli/role)

## Ownership
Ownership is the model used for resource control composed of the owner and a
list of groups and collaborators with access to the resource. Groups and
collaborators can also have their access to a resource contrained by their
access type. The following table defines the three access types supported:

| Type | Description |
| ---- | ----------- |
| Read | Has access to only view or copy the resource. Cannot affect or mutate the resource. |
| Write | Has _Read_ access plus the permission to change the resource. |
| Admin | Has _Write_ access plus the ability to delete the resource. |

For example, `user1` could create a volume and give access to `group1`
with the access type of _Read_. This means that only `user1` can mount the
volume, but `group1` can clone the volume to make their own. When a volume is
cloned, then new volume gains the ownership of the new user of the request.

## Administrator
Similar to the `root` user in a Linux system, Portworx has a concept of a system administrator. A
system administrator is one that is not constrained by RBAC and one that
participates in every group. Portworx has an RBAC role for administrators
already created called `system.admin`. This only gives the caller access to
every API call. To have access to every resource, they must be in group `*`,
meaning, they are part of every group. Their token claims would then have the
following information:

```json
{
  "roles" : [ "system.admin" ],
  "groups": [ "*" ]
}
```

## References
For more inforamtion, see also:

* [OpenID Connect](https://openid.net)
* [JWT.io](https://jwt.io)
* [OpenStorge SDK](https://libopenstorage.github.io/w/)
* [Authorization with pxctl](/reference/cli/authorization)
* [Role management with pxctl](/reference/cli/role)

